package net.ionoff.common.validation.codegen;

import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.File;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;

import static java.nio.file.Files.readAllLines;

/**
 * This class is to insert constraint annotations and import required package to java api model generated by swagger-codegen-maven-plugin
 * To do that, it reads constraint annotations from api json file (defined in 'description' of schema or schema property)
 * Tested with java model generated by swagger-codegen-maven-plugin version 3.0.0 to 3.0.22, language spring and library spring-mvc
 */
public class ConstraintAnnotationCodeGen {

    public static final String DESCRIPTION = "description";
    public static final String PROPERTIES = "properties";

    private static String apiFile;
    private static String modelDir;
    private static String modelNameSuffix;
    private static Set<String> validationPackages;

    public static void main(String[] args) throws IOException {
        Map<String, String> arguments = createArgumentsMap(args);
        apiFile = arguments.get("--api_file");
        modelDir = arguments.get("--model_dir");
        modelNameSuffix = arguments.getOrDefault("--model_name_suffix", "");
        validationPackages = createValidationPackages(arguments.getOrDefault("--validation_packages", ""));

        if (apiFile == null) {
            throw new IllegalArgumentException("!!! Missing argument, '--api_file' is required");
        }
        if (modelDir == null) {
            throw new IllegalArgumentException("!!! Missing argument, '--model_dir' is required");
        }

        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.configure(JsonParser.Feature.ALLOW_COMMENTS, true);
        JsonNode apiJson = objectMapper.readTree(new File(apiFile));

        JsonNode schemas = apiJson.get("components").get("schemas");
        Iterator<Map.Entry<String, JsonNode>> schemasIterator = schemas.fields();

        while (schemasIterator.hasNext()) {
            Map.Entry<String, JsonNode> schemaEntry = schemasIterator.next();
            insertConstrainValidationAnnotations(schemaEntry.getValue(), schemaEntry.getKey());
        }
    }

    private static void insertConstrainValidationAnnotations(JsonNode schema, String schemaName) throws IOException {
        if (!schema.has(DESCRIPTION)) {
            return;
        }
        String[] descriptionItems = schema.get(DESCRIPTION).asText().split("\\|");
        if (!isUseConstraintValidation(descriptionItems)) {
            return;
        }

        Path path = Paths.get(getJavaModelFile(schemaName));
        Charset charset = StandardCharsets.UTF_8;
        List<String> javaModelFileContent = new LinkedList<>(readAllLines(path, charset));

        importConstraintValidationPackages(javaModelFileContent);
        insertConstraintValidationAnnotationsForClass(javaModelFileContent, schemaName, descriptionItems);
        if (schema.has(PROPERTIES)) {
            insertConstraintValidationAnnotationForProperties(javaModelFileContent, schema.get(PROPERTIES));
        }
        Files.write(path, javaModelFileContent, charset);
    }


    private static void importConstraintValidationPackages(List<String> javaModelFileContent) {
        for (String validationPackage : validationPackages) {
            importConstraintValidationPackages(javaModelFileContent, validationPackage);
        }
    }

    private static void importConstraintValidationPackages(List<String> javaModelFileContent, String validationPackage) {
        for (int i = 0; i < javaModelFileContent.size(); i++) {
            if (javaModelFileContent.get(i).startsWith("import javax.validation.Valid;")) {
                javaModelFileContent.add(i, "import " + validationPackage + ".*;");
                break;
            }
        }
    }

    private static void insertConstraintValidationAnnotationsForClass(List<String> javaModelFileContent, String schemaName, String[] schemaDescriptionItems) {
        for (String schemaDescriptionItem : schemaDescriptionItems) {
            schemaDescriptionItem = schemaDescriptionItem.trim();
            if (schemaDescriptionItem.startsWith("@")) {
                String insertBeforeLine = "public class " + schemaName + "Dto";
                insertConstraintValidationAnnotationForClass(javaModelFileContent, insertBeforeLine, schemaDescriptionItem);
            }
        }
    }

    private static void insertConstraintValidationAnnotationForClass(List<String> javaModelFileContent, String insertBeforeLine, String constraintValidationAnnotation) {
        for (int line = 0; line < javaModelFileContent.size(); line++) {
            if (javaModelFileContent.get(line).startsWith(insertBeforeLine)) {
                javaModelFileContent.add(line, constraintValidationAnnotation);
                break;
            }
        }
    }

    private static void insertConstraintValidationAnnotationForProperties(List<String> javaModelFileContent, JsonNode properties) {
        Iterator<Map.Entry<String, JsonNode>> propertyIterator = properties.fields();
        while (propertyIterator.hasNext()) {
            Map.Entry<String, JsonNode> propertyEntry = propertyIterator.next();
            JsonNode propertyObj = propertyEntry.getValue();
            if (propertyObj.has(DESCRIPTION)) {
                String propertyDescription = propertyObj.get(DESCRIPTION).asText();
                String[] propertyDescriptionItems = propertyDescription.split("\\|");
                insertConstraintValidationAnnotationForProperty(javaModelFileContent, propertyEntry.getKey(), propertyDescriptionItems);
            }
        }
    }

    private static void insertConstraintValidationAnnotationForProperty(List<String> javaModelFileContent, String propertyName, String[] propertyDescriptionItems) {
        for (String descriptionItem : propertyDescriptionItems) {
            descriptionItem = descriptionItem.trim();
            if (descriptionItem.startsWith("@")) {
                String insertBeforeLine = "@JsonProperty(\"" + propertyName + "\")";
                insertConstraintValidationAnnotationForProperty(javaModelFileContent, insertBeforeLine, descriptionItem);
            }
        }
    }

    private static void insertConstraintValidationAnnotationForProperty(List<String> javaModelFileContent, String insertBeforeLine, String constraintValidationAnnotation) {
        for (int line = 0; line < javaModelFileContent.size(); line++) {
            if (javaModelFileContent.get(line).contains(insertBeforeLine)) {
                javaModelFileContent.add(line, "  " + constraintValidationAnnotation);
                break;
            }
        }
    }

    private static String getJavaModelFile(String schemaName) {
        return modelDir + File.separator + schemaName + modelNameSuffix + ".java";
    }

    private static boolean isUseConstraintValidation(String[] schemaDescriptionItems) {
        for (String descriptionItem : schemaDescriptionItems) {
            descriptionItem = descriptionItem.trim();
            if ("!UseConstraintValidation".equals(descriptionItem)) {
                return true;
            }
        }
        return false;
    }

    private static Map<String, String> createArgumentsMap(String[] args) {
        Map<String, String> arguments = new HashMap<>();
        for (int i = 0; i < args.length; i = i + 2) {
            if (i + 1 < args.length) {
                arguments.put(args[i], args[i + 1]);
            } else {
                arguments.put(args[i], "");
            }
        }
        return arguments;
    }
    private static Set<String> createValidationPackages(String validationPackage) {
        Set<String> validationPackageSet = new HashSet<>();
        String defaultValidationPackage = "net.ionoff.common.validation.constraints";
        validationPackageSet.add(defaultValidationPackage);
        for (String pkg : validationPackage.split(",")) {
            if (!pkg.isEmpty()) {
                validationPackageSet.add(pkg);
            }
        }
        return validationPackageSet;

    }
}


